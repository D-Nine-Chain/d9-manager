#!/usr/bin/env -S deno run --allow-all

import { Command } from "@cliffy/command";
import { Select, Confirm } from "@cliffy/prompt";
import { colors } from "@cliffy/ansi";
import { getMessage } from "./i18n.ts";
import { Messages } from "./types.ts";
import { checkSystemRequirements, createProgressBar } from "./utils/system.ts";
import { hasValidKeystore, getNodeAddress, getDataDirectory } from "./utils/keystore.ts";
import { getD9API, disconnectD9API } from "./utils/polkadot.ts";
import { checkBalanceWithPrompt, formatBalance } from "./utils/balance.ts";
import { setupNode } from "./commands/setup.ts";
import { setupNodeV2 } from "./commands/setup-v2.ts";
import { submitCandidacy } from "./commands/candidacy.ts";
import { convertNode } from "./commands/convert.ts";
import { hasResumableInstallation, promptResume, clearAbandonedInstallation, showInstallationState } from "./commands/resume.ts";
import { SERVICE } from "./config/constants.ts";

// Import version info - this file is generated by Makefile
let VERSION = "dev";
let COMMIT = "unknown"; 
let BUILD_DATE = "unknown";

try {
  const versionModule = await import("./version.ts");
  VERSION = versionModule.VERSION;
  COMMIT = versionModule.COMMIT;
  BUILD_DATE = versionModule.BUILD_DATE;
} catch {
  // Use defaults if version.ts doesn't exist
}

async function main() {
	console.clear();

	// Language selection
	const language = await Select.prompt({
		message: "Choose your language / ÈÄâÊã©ÊÇ®ÁöÑËØ≠Ë®Ä:",
		options: [
			{ name: "English", value: "en" },
			{ name: "‰∏≠Êñá", value: "zh" },
		],
	});

	const messages = getMessage(language as "en" | "zh");

	console.clear();
	console.log(colors.blue.bold(messages.welcome));
	console.log(colors.gray(`Version: ${VERSION}`));
	console.log(colors.gray(`Commit: ${COMMIT}`));
	console.log(colors.gray(`Built: ${BUILD_DATE}`));
	console.log("‚ïê".repeat(50));

	// Check for resumable installation
	const canResume = await hasResumableInstallation();
	if (canResume) {
		const shouldResume = await promptResume();
		if (shouldResume) {
			// Note: Resume functionality would go here
			// For now, we just show the state and continue
			console.log('\n‚ö†Ô∏è  Resume functionality requires integration with transactional setup');
			console.log('üí° Clear the state to start fresh, or continue to main menu');
			await Confirm.prompt('Continue to main menu?');
		}
	}

	// Check system and D9 binary
	console.log(messages.checkingBinary);
	const systemInfo = await checkSystemRequirements();

	if (!systemInfo.hasD9Binary) {
		console.log(`\n‚ö†Ô∏è  ${messages.binaryNotFound}`);
		const install = await Confirm.prompt("Install D9 node?");
		if (install) {
			await setupNodeV2(messages);
			return;
		} else {
			console.log("‚ùå D9 node binary is required. Exiting.");
			return;
		}
	}

	console.log(`‚úÖ D9 binary found at: ${systemInfo.binaryPath}`);

	// Check keystore access
	console.log("\nüìÅ Keystore Check");
	console.log("‚îÄ".repeat(30));
	const keyAccess = await Confirm.prompt(messages.keyAccessPrompt);
	if (!keyAccess) {
		console.log("‚ùå Keystore access is required for most operations. Exiting.");
		return;
	}

	let hasKeys = false;
	try {
		hasKeys = await hasValidKeystore();
	} catch (error) {
		console.error("\n‚ùå Error checking keystore:");
		console.error(`   ${error instanceof Error ? error.message : String(error)}`);
		if (error instanceof Error && error.stack) {
			console.error(`   Stack: ${error.stack}`);
		}
	}

	if (!hasKeys) {
		console.log(`\n‚ö†Ô∏è  ${messages.errors.keyNotFound}`);
		const setupNew = await Confirm.prompt("Setup new node with keys?");
		if (setupNew) {
			await setupNodeV2(messages);
			return;
		} else {
			console.log("‚ùå Valid keystore is required. Exiting.");
			return;
		}
	}

	// Get node address and check balance
	let nodeAddress: string | null = null;
	try {
		nodeAddress = await getNodeAddress();
	} catch (error) {
		console.error("\n‚ùå Error getting node address:");
		console.error(`   ${error instanceof Error ? error.message : String(error)}`);
		if (error instanceof Error && error.stack) {
			console.error(`   Stack: ${error.stack}`);
		}
	}

	if (nodeAddress) {
		console.log(`\nüîó Node Address: ${nodeAddress}`);

		try {
			await createProgressBar(1500, messages.checkingBalance);
			await checkBalanceWithPrompt(nodeAddress);
		} catch (error) {
			console.error(`\n‚ö†Ô∏è  Could not check balance:`);
			console.error(`   ${error instanceof Error ? error.message : String(error)}`);
			if (error instanceof Error && error.stack) {
				console.error(`   Stack: ${error.stack}`);
			}
		}
	}

	// Main menu loop
	let continueLoop = true;
	while (continueLoop) {
		console.log(`\n${messages.mainMenu}`);

		const action = await Select.prompt({
			message: "Select an option:",
			options: [
				{ name: "üöÄ " + messages.setupNewNode, value: "setup" },
				{ name: "üó≥Ô∏è  " + messages.submitCandidacy, value: "candidacy" },
				{ name: "üîÑ " + messages.convertNode, value: "convert" },
				{ name: "üìä Check node status", value: "status" },
				{ name: "üíæ Show installation state", value: "show-state" },
				{ name: "üóëÔ∏è  Clear installation state", value: "clear-state" },
				{ name: "üö™ Exit", value: "exit" },
			],
		});

		try {
			switch (action) {
				case "setup":
					await setupNodeV2(messages);
					break;
				case "candidacy":
					await submitCandidacy(messages);
					break;
				case "convert":
					await convertNode(messages);
					break;
				case "status":
					await showNodeStatus();
					break;
				case "show-state":
					await showInstallationState();
					break;
				case "clear-state":
					await clearAbandonedInstallation();
					break;
				case "exit":
					continueLoop = false;
					break;
			}
		} catch (error) {
			console.error(`\n‚ùå Error executing action:`);
			console.error(`   Action: ${action}`);
			console.error(`   Error: ${error instanceof Error ? error.message : String(error)}`);
			if (error instanceof Error && error.stack) {
				console.error(`   Stack trace: ${error.stack}`);
			}
		}

		if (continueLoop && action !== "exit") {
			const continueProm = await Confirm.prompt("\nReturn to main menu?");
			if (!continueProm) {
				continueLoop = false;
			}
			console.clear();
			console.log(colors.blue.bold(messages.welcome));
			console.log("‚ïê".repeat(50));
		}
	}

	// Disconnect API before exiting
	await disconnectD9API();
	console.log("\nüëã Goodbye!");
}

async function showNodeStatus(): Promise<void> {
	console.log("\nüìä Node Status");
	console.log("‚îÄ".repeat(30));

	try {
		// Check if service is running
		const statusProcess = new Deno.Command("sudo", {
			args: ["systemctl", "is-active", SERVICE.NAME],
		});
		const statusResult = await statusProcess.output();
		const isActive = new TextDecoder().decode(statusResult.stdout).trim() === "active";

		console.log(`Service Status: ${isActive ? "‚úÖ Running" : "‚ùå Stopped"}`);

		if (isActive) {
			// Get recent logs
			const logsProcess = new Deno.Command("sudo", {
				args: ["journalctl", "-u", SERVICE.NAME, "-n", "5", "--no-pager"],
			});
			const logsResult = await logsProcess.output();
			const logs = new TextDecoder().decode(logsResult.stdout);

			console.log("\nüìù Recent Logs:");
			console.log("‚îÄ".repeat(20));
			console.log(logs);
		}

		// Show disk usage - use actual data directory
		const dataDir = await getDataDirectory();
		if (dataDir) {
			const dfProcess = new Deno.Command("df", { args: ["-h", dataDir] });
			const dfResult = await dfProcess.output();
			if (dfResult.code === 0) {
				const diskInfo = new TextDecoder().decode(dfResult.stdout);
				console.log("\nüíæ Disk Usage:");
				console.log("‚îÄ".repeat(15));
				console.log(diskInfo);
			}
		}
	} catch (error) {
		console.log(
			`‚ùå Error checking status: ${error instanceof Error ? error.message : String(error)}`,
		);
	}

	console.log("\nüí° Useful commands:");
	console.log(`  View logs: journalctl -u ${SERVICE.NAME} -f`);
	console.log(`  Stop node: sudo systemctl stop ${SERVICE.NAME}`);
	console.log(`  Start node: sudo systemctl start ${SERVICE.NAME}`);
	console.log(`  Restart: sudo systemctl restart ${SERVICE.NAME}`);
}

// CLI definition for potential future use
const cli = new Command()
	.name("d9-manager")
	.version(VERSION)
	.description("D9 Node Management Tool")
	.action(main);

if (import.meta.main) {
	await main();
}
